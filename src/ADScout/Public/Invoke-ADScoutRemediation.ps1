function Invoke-ADScoutRemediation {
    <#
    .SYNOPSIS
        Executes remediation actions for AD-Scout findings with WhatIf and rollback support.

    .DESCRIPTION
        Executes remediation scripts generated by AD-Scout with full support for:
        - WhatIf simulation mode to preview changes without applying them
        - Confirm prompts for each remediation action
        - Batch execution of multiple remediations
        - Automatic rollback capability with state capture
        - Change management integration (JIRA, etc.)

    .PARAMETER Results
        Scan results from Invoke-ADScoutScan containing findings to remediate.

    .PARAMETER Finding
        A specific finding object to remediate.

    .PARAMETER RuleId
        Filter to remediate only specific rule IDs.

    .PARAMETER BatchId
        Optional batch identifier for grouping remediations. Auto-generated if not specified.

    .PARAMETER EnableRollback
        Capture state before each change to enable rollback. Default is $true.

    .PARAMETER RollbackPath
        Path to store rollback data. Defaults to $env:TEMP\ADScout\Rollback.

    .PARAMETER ChangeTicket
        Change management ticket ID (e.g., JIRA issue key) to link with this remediation.

    .PARAMETER MaxParallel
        Maximum number of parallel remediations. Default is 1 (sequential).

    .PARAMETER StopOnError
        Stop batch execution if any remediation fails. Default is $false.

    .PARAMETER PassThru
        Return detailed remediation result objects.

    .EXAMPLE
        Invoke-ADScoutScan | Invoke-ADScoutRemediation -WhatIf
        Simulates remediation for all findings without making changes.

    .EXAMPLE
        $results = Invoke-ADScoutScan -RuleId "S-PwdNeverExpires"
        Invoke-ADScoutRemediation -Results $results -Confirm:$false -EnableRollback
        Executes remediation with rollback capability enabled.

    .EXAMPLE
        Invoke-ADScoutRemediation -Results $results -ChangeTicket "ITSEC-1234"
        Links remediation to a change ticket for audit trail.

    .OUTPUTS
        ADScoutRemediationResult
        Detailed remediation execution results when -PassThru is specified.

    .NOTES
        Author: AD-Scout Contributors
    #>
    [CmdletBinding(SupportsShouldProcess, ConfirmImpact = 'High', DefaultParameterSetName = 'ByResults')]
    param(
        [Parameter(ParameterSetName = 'ByResults', ValueFromPipeline, Mandatory)]
        [PSCustomObject[]]$Results,

        [Parameter(ParameterSetName = 'ByFinding', Mandatory)]
        [PSCustomObject]$Finding,

        [Parameter()]
        [string[]]$RuleId,

        [Parameter()]
        [string]$BatchId = [guid]::NewGuid().ToString('N').Substring(0, 8),

        [Parameter()]
        [switch]$EnableRollback = $true,

        [Parameter()]
        [string]$RollbackPath = (Join-Path $env:TEMP 'ADScout\Rollback'),

        [Parameter()]
        [string]$ChangeTicket,

        [Parameter()]
        [ValidateRange(1, 10)]
        [int]$MaxParallel = 1,

        [Parameter()]
        [switch]$StopOnError,

        [Parameter()]
        [switch]$PassThru
    )

    begin {
        $allResults = @()
        $remediationResults = @()
        $batchStartTime = Get-Date

        # Create rollback directory if enabled
        if ($EnableRollback -and -not (Test-Path $RollbackPath)) {
            $null = New-Item -ItemType Directory -Path $RollbackPath -Force
        }

        # Initialize batch manifest
        $batchManifest = @{
            BatchId         = $BatchId
            StartTime       = $batchStartTime
            ChangeTicket    = $ChangeTicket
            WhatIf          = $WhatIfPreference
            Remediations    = @()
            Status          = 'InProgress'
            RollbackEnabled = $EnableRollback
        }

        Write-ADScoutLog -Message "Starting remediation batch: $BatchId" -Level Info
        if ($ChangeTicket) {
            Write-ADScoutLog -Message "Linked to change ticket: $ChangeTicket" -Level Info
        }
    }

    process {
        if ($Results) {
            $allResults += $Results
        }
    }

    end {
        # Handle single finding mode
        if ($PSCmdlet.ParameterSetName -eq 'ByFinding') {
            $allResults = @([PSCustomObject]@{
                RuleId       = $Finding.RuleId
                RuleName     = $Finding.RuleName
                Findings     = @($Finding)
                FindingCount = 1
            })
        }

        # Filter by RuleId if specified
        if ($RuleId) {
            $allResults = $allResults | Where-Object { $_.RuleId -in $RuleId }
        }

        if (-not $allResults -or $allResults.Count -eq 0) {
            Write-Warning "No findings to remediate."
            return
        }

        # Process each result
        foreach ($result in $allResults) {
            $rule = Get-ADScoutRule -Id $result.RuleId

            if (-not $rule -or -not $rule.Remediation) {
                Write-Warning "No remediation available for rule: $($result.RuleId)"
                continue
            }

            foreach ($findingItem in $result.Findings) {
                $remediationId = [guid]::NewGuid().ToString('N').Substring(0, 8)
                $remediationRecord = @{
                    RemediationId   = $remediationId
                    RuleId          = $result.RuleId
                    RuleName        = $result.RuleName
                    Finding         = $findingItem
                    StartTime       = Get-Date
                    Status          = 'Pending'
                    RollbackData    = $null
                    Script          = $null
                    Output          = $null
                    Error           = $null
                }

                try {
                    # Generate remediation script
                    $remediationScript = & $rule.Remediation -Finding $findingItem
                    $remediationRecord.Script = $remediationScript

                    # Determine the target identity for display
                    $targetIdentity = Get-RemediationTargetIdentity -Finding $findingItem

                    # WhatIf simulation
                    if ($WhatIfPreference) {
                        $whatIfOutput = Get-RemediationWhatIf -Finding $findingItem -Rule $rule -Script $remediationScript
                        $remediationRecord.Status = 'Simulated'
                        $remediationRecord.Output = $whatIfOutput

                        Write-Host "`n$whatIfOutput" -ForegroundColor Cyan
                    }
                    elseif ($PSCmdlet.ShouldProcess($targetIdentity, "Apply remediation for $($result.RuleName)")) {
                        # Capture rollback state before changes
                        if ($EnableRollback) {
                            $rollbackData = Get-RemediationRollbackState -Finding $findingItem -Rule $rule
                            $remediationRecord.RollbackData = $rollbackData

                            # Save rollback data to file
                            $rollbackFile = Join-Path $RollbackPath "$BatchId`_$remediationId.json"
                            $rollbackData | ConvertTo-Json -Depth 10 | Set-Content -Path $rollbackFile -Encoding UTF8
                        }

                        # Execute remediation
                        $output = Invoke-RemediationScript -Script $remediationScript -Finding $findingItem
                        $remediationRecord.Status = 'Completed'
                        $remediationRecord.Output = $output
                        $remediationRecord.EndTime = Get-Date

                        Write-ADScoutLog -Message "Remediation completed for $targetIdentity ($($result.RuleId))" -Level Info
                    }
                    else {
                        $remediationRecord.Status = 'Skipped'
                    }
                }
                catch {
                    $remediationRecord.Status = 'Failed'
                    $remediationRecord.Error = $_.Exception.Message
                    $remediationRecord.EndTime = Get-Date

                    Write-ADScoutLog -Message "Remediation failed for $($result.RuleId): $_" -Level Error

                    if ($StopOnError) {
                        $batchManifest.Status = 'Failed'
                        throw "Remediation batch stopped due to error: $_"
                    }
                }

                $remediationResults += [PSCustomObject]$remediationRecord
                $batchManifest.Remediations += $remediationRecord
            }
        }

        # Finalize batch
        $batchManifest.EndTime = Get-Date
        $batchManifest.Status = if ($remediationResults | Where-Object Status -eq 'Failed') { 'PartialFailure' } else { 'Completed' }

        # Save batch manifest
        if ($EnableRollback) {
            $manifestFile = Join-Path $RollbackPath "$BatchId`_manifest.json"
            $batchManifest | ConvertTo-Json -Depth 10 | Set-Content -Path $manifestFile -Encoding UTF8
        }

        # Summary output
        $summary = @{
            BatchId       = $BatchId
            TotalFindings = $remediationResults.Count
            Completed     = ($remediationResults | Where-Object Status -eq 'Completed').Count
            Simulated     = ($remediationResults | Where-Object Status -eq 'Simulated').Count
            Skipped       = ($remediationResults | Where-Object Status -eq 'Skipped').Count
            Failed        = ($remediationResults | Where-Object Status -eq 'Failed').Count
            Duration      = (Get-Date) - $batchStartTime
            ChangeTicket  = $ChangeTicket
            RollbackPath  = if ($EnableRollback) { $RollbackPath } else { $null }
        }

        Write-Host "`n=== Remediation Batch Summary ===" -ForegroundColor Green
        Write-Host "Batch ID:    $($summary.BatchId)"
        Write-Host "Total:       $($summary.TotalFindings)"
        Write-Host "Completed:   $($summary.Completed)" -ForegroundColor Green
        Write-Host "Simulated:   $($summary.Simulated)" -ForegroundColor Cyan
        Write-Host "Skipped:     $($summary.Skipped)" -ForegroundColor Yellow
        Write-Host "Failed:      $($summary.Failed)" -ForegroundColor Red
        Write-Host "Duration:    $($summary.Duration.ToString('mm\:ss'))"
        if ($ChangeTicket) {
            Write-Host "Ticket:      $ChangeTicket"
        }
        if ($EnableRollback) {
            Write-Host "Rollback:    $RollbackPath"
        }

        if ($PassThru) {
            [PSCustomObject]@{
                PSTypeName    = 'ADScoutRemediationBatchResult'
                BatchId       = $BatchId
                Summary       = [PSCustomObject]$summary
                Remediations  = $remediationResults
                RollbackPath  = if ($EnableRollback) { $RollbackPath } else { $null }
            }
        }
    }
}

function Get-RemediationTargetIdentity {
    <#
    .SYNOPSIS
        Extracts a human-readable identity from a finding object.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [PSCustomObject]$Finding
    )

    # Try common identity properties in order of preference
    $identityProperties = @(
        'SamAccountName',
        'UserPrincipalName',
        'Name',
        'DisplayName',
        'DistinguishedName',
        'ObjectGUID',
        'Identity',
        'Target'
    )

    foreach ($prop in $identityProperties) {
        if ($Finding.PSObject.Properties[$prop] -and $Finding.$prop) {
            return $Finding.$prop
        }
    }

    return "Unknown Object"
}

function Get-RemediationWhatIf {
    <#
    .SYNOPSIS
        Generates WhatIf simulation output for a remediation action.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [PSCustomObject]$Finding,

        [Parameter(Mandatory)]
        [hashtable]$Rule,

        [Parameter(Mandatory)]
        [string]$Script
    )

    $targetIdentity = Get-RemediationTargetIdentity -Finding $Finding

    $output = @"
╔══════════════════════════════════════════════════════════════════════════════╗
║ WHATIF: Remediation Simulation                                               ║
╠══════════════════════════════════════════════════════════════════════════════╣
║ Rule:   $($Rule.Id.PadRight(66))║
║ Target: $($targetIdentity.ToString().PadRight(66).Substring(0, 66))║
╠══════════════════════════════════════════════════════════════════════════════╣
║ Actions that would be performed:                                             ║
╚══════════════════════════════════════════════════════════════════════════════╝

"@

    # Parse the script to extract actionable commands
    $actions = Get-ScriptActions -Script $Script
    foreach ($action in $actions) {
        $output += "  → $action`n"
    }

    $output += @"

╔══════════════════════════════════════════════════════════════════════════════╗
║ No changes were made. Use -WhatIf:`$false to apply changes.                  ║
╚══════════════════════════════════════════════════════════════════════════════╝
"@

    return $output
}

function Get-ScriptActions {
    <#
    .SYNOPSIS
        Parses a remediation script to extract human-readable action descriptions.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Script
    )

    $actions = @()

    # Common AD cmdlet patterns and their descriptions
    $cmdletPatterns = @{
        'Set-ADUser'              = 'Modify user account'
        'Set-ADComputer'          = 'Modify computer account'
        'Set-ADGroup'             = 'Modify group'
        'Set-ADAccountPassword'   = 'Reset password'
        'Add-ADGroupMember'       = 'Add member to group'
        'Remove-ADGroupMember'    = 'Remove member from group'
        'Disable-ADAccount'       = 'Disable account'
        'Enable-ADAccount'        = 'Enable account'
        'Remove-ADUser'           = 'Delete user account'
        'Remove-ADComputer'       = 'Delete computer account'
        'Set-ADAccountExpiration' = 'Set account expiration'
        'Unlock-ADAccount'        = 'Unlock account'
        'Set-Acl'                 = 'Modify permissions (ACL)'
        'Remove-ItemProperty'     = 'Remove property/attribute'
        'Set-ADObject'            = 'Modify AD object'
    }

    foreach ($line in $Script -split "`n") {
        $trimmedLine = $line.Trim()

        # Skip comments and empty lines
        if ($trimmedLine -match '^\s*#' -or [string]::IsNullOrWhiteSpace($trimmedLine)) {
            continue
        }

        foreach ($cmdlet in $cmdletPatterns.Keys) {
            if ($trimmedLine -match [regex]::Escape($cmdlet)) {
                # Extract key parameters for context
                $action = $cmdletPatterns[$cmdlet]

                # Try to extract identity parameter
                if ($trimmedLine -match "-Identity\s+[`"']?([^`"'\s]+)") {
                    $action += ": $($Matches[1])"
                }
                elseif ($trimmedLine -match "-Identity\s+\`$\(([^)]+)\)") {
                    $action += ": <dynamic>"
                }

                # Extract specific parameter values for context
                if ($trimmedLine -match "-PasswordNeverExpires\s+\`$false") {
                    $action += " (set password expiration policy)"
                }
                if ($trimmedLine -match "-Enabled\s+\`$false") {
                    $action += " (disable)"
                }

                $actions += $action
                break
            }
        }
    }

    if ($actions.Count -eq 0) {
        $actions += "Execute custom remediation script"
    }

    return $actions | Select-Object -Unique
}

function Get-RemediationRollbackState {
    <#
    .SYNOPSIS
        Captures the current state of an object before remediation for rollback purposes.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [PSCustomObject]$Finding,

        [Parameter(Mandatory)]
        [hashtable]$Rule
    )

    $rollbackData = @{
        CapturedAt = Get-Date
        RuleId     = $Rule.Id
        Finding    = $Finding
        ObjectType = $null
        Identity   = $null
        State      = $null
    }

    # Determine object type and capture state
    $identity = Get-RemediationTargetIdentity -Finding $Finding

    try {
        # Try to determine object type from finding or rule category
        if ($Finding.PSObject.Properties['objectClass']) {
            $objectClass = $Finding.objectClass
        }
        elseif ($Rule.Category -eq 'StaleObjects' -or $Rule.Id -match '^S-') {
            $objectClass = 'user'  # Most stale object rules target users
        }
        else {
            $objectClass = 'unknown'
        }

        $rollbackData.ObjectType = $objectClass

        # Capture current state based on object type
        switch -Regex ($objectClass) {
            'user' {
                if ($Finding.PSObject.Properties['DistinguishedName']) {
                    $rollbackData.Identity = $Finding.DistinguishedName
                    $currentState = Get-ADUser -Identity $Finding.DistinguishedName -Properties *
                    $rollbackData.State = $currentState | Select-Object -Property @(
                        'SamAccountName', 'Enabled', 'PasswordNeverExpires', 'PasswordNotRequired',
                        'AccountExpirationDate', 'PasswordLastSet', 'LastLogonDate',
                        'CannotChangePassword', 'LockedOut', 'MemberOf', 'Description',
                        'UserAccountControl', 'DistinguishedName'
                    )
                }
            }
            'computer' {
                if ($Finding.PSObject.Properties['DistinguishedName']) {
                    $rollbackData.Identity = $Finding.DistinguishedName
                    $currentState = Get-ADComputer -Identity $Finding.DistinguishedName -Properties *
                    $rollbackData.State = $currentState | Select-Object -Property @(
                        'Name', 'Enabled', 'OperatingSystem', 'LastLogonDate',
                        'PasswordLastSet', 'MemberOf', 'Description', 'DistinguishedName'
                    )
                }
            }
            'group' {
                if ($Finding.PSObject.Properties['DistinguishedName']) {
                    $rollbackData.Identity = $Finding.DistinguishedName
                    $currentState = Get-ADGroup -Identity $Finding.DistinguishedName -Properties *
                    $members = Get-ADGroupMember -Identity $Finding.DistinguishedName | Select-Object -ExpandProperty DistinguishedName
                    $rollbackData.State = $currentState | Select-Object -Property @(
                        'Name', 'GroupCategory', 'GroupScope', 'Description', 'DistinguishedName'
                    )
                    $rollbackData.State | Add-Member -NotePropertyName 'Members' -NotePropertyValue $members
                }
            }
            default {
                # Generic state capture - just store the finding
                $rollbackData.State = $Finding
            }
        }
    }
    catch {
        Write-ADScoutLog -Message "Could not capture rollback state: $_" -Level Warning
        $rollbackData.State = $Finding
        $rollbackData.CaptureError = $_.Exception.Message
    }

    return $rollbackData
}

function Invoke-RemediationScript {
    <#
    .SYNOPSIS
        Safely executes a remediation script with error handling.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Script,

        [Parameter(Mandatory)]
        [PSCustomObject]$Finding
    )

    $output = @{
        StartTime  = Get-Date
        Commands   = @()
        Success    = $true
        Messages   = @()
    }

    try {
        # Create a script block from the remediation script
        $scriptBlock = [ScriptBlock]::Create($Script)

        # Execute in a child scope to prevent variable pollution
        $executionResult = & $scriptBlock

        $output.Messages += "Remediation executed successfully"
        $output.Result = $executionResult
    }
    catch {
        $output.Success = $false
        $output.Messages += "Error: $($_.Exception.Message)"
        $output.Error = $_
        throw
    }
    finally {
        $output.EndTime = Get-Date
        $output.Duration = $output.EndTime - $output.StartTime
    }

    return [PSCustomObject]$output
}
